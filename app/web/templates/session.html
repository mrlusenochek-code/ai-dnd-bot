<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <title>Session {{ session_id }}</title>
  <style>
    body{font-family:Arial, sans-serif; margin:0;}
    .wrap{display:grid; grid-template-columns: 1fr 320px; gap:0; height:100vh;}
    .main{padding:16px; overflow:auto;}
    .side{border-left:1px solid #333; padding:16px; overflow:auto;}
    .log{border:1px solid #333; border-radius:10px; padding:12px; height:60vh; overflow:auto; background:#0f0f0f; color:#eaeaea;}
    .row{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap;}
    input{flex:1; padding:10px; font-size:16px; min-width:220px;}
    button{padding:10px; font-size:14px;}
    button:disabled{opacity:.55; cursor:not-allowed;}
    .player{padding:8px 10px; border:1px solid #333; border-radius:10px; margin-top:8px; white-space:pre-wrap;}
    .cur{border-color:#6cff6c;}
    .muted{opacity:.75}
    code{background:#eee; padding:2px 6px; border-radius:6px;}
  
    .hintline{margin-top:8px; font-size:14px; opacity:.85}
    .input-ok{border:2px solid #6cff6c;}
    .input-wait{border:2px solid #ffdf6c;}
    .input-bad{border:2px solid #ff7a7a;}
    .hint-ok{color:#6cff6c}
    .hint-wait{color:#ffdf6c}
    .hint-bad{color:#ff7a7a}
    .player.me{border-style:dashed;}
    .player.inactive{opacity:.5; filter:grayscale(.3);}
    button:disabled{opacity:.45; cursor:not-allowed;}
    input:disabled{opacity:.6;}
    .char-card{cursor:pointer; transition:box-shadow .15s ease, border-color .15s ease, transform .15s ease;}
    .char-card:hover{border-color:#5a8dff; box-shadow:0 6px 14px rgba(0,0,0,.18); transform:translateY(-1px);}
    .char-card:focus-visible{outline:2px solid #5a8dff; outline-offset:2px;}
    .char-modal{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; padding:16px; z-index:1000;}
    .char-modal.open{display:flex;}
    .char-modal-window{width:min(680px,100%); max-height:85vh; overflow:auto; background:#fff; border-radius:12px; border:1px solid #dcdcdc; box-shadow:0 18px 48px rgba(0,0,0,.3); padding:16px 16px 14px;}
    .char-modal-head{display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom:10px;}
    .char-modal-actions{display:flex; align-items:center; gap:8px;}
    .char-modal-title{margin:0; font-size:20px;}
    .char-modal-copy{padding:6px 10px; font-size:13px; border:1px solid #cfcfcf; border-radius:8px; background:#fafafa; cursor:pointer;}
    .char-modal-copy:disabled{opacity:.55; cursor:not-allowed;}
    .char-modal-close{padding:4px 10px; font-size:20px; line-height:1; border:1px solid #cfcfcf; border-radius:8px; background:#fafafa; cursor:pointer;}
    .char-modal-toast{font-size:12px; color:#1f7a2f; opacity:0; transform:translateY(-2px); transition:opacity .18s ease, transform .18s ease; pointer-events:none;}
    .char-modal-toast.show{opacity:1; transform:translateY(0);}
    .char-grid{display:grid; gap:8px;}
    .char-line{padding:8px 10px; border:1px solid #ececec; border-radius:8px; background:#fafafa; white-space:pre-wrap;}
    .char-list{margin:0; padding-left:20px;}
    .char-list li{margin:4px 0;}
    .combat-log{margin-top:10px; border:1px solid #333; border-radius:10px; background:#121212;}
    .combat-log-toggle{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      border:0;
      background:transparent;
      color:#eaeaea;
      padding:10px 12px;
      cursor:pointer;
      font-size:14px;
      text-align:left;
    }
    .combat-log-toggle:hover{background:rgba(255,255,255,.04);}
    .combat-log-indicator{opacity:.9;}
    .combat-log-content{
      border-top:1px solid rgba(255,255,255,.1);
      padding:10px 12px;
      max-height:130px;
      overflow:auto;
      color:#cfcfcf;
      font-size:13px;
      line-height:1.4;
    }
    .combat-log-status{font-weight:600; color:#eaeaea; margin-bottom:6px;}
    .combat-log-placeholder{opacity:.75; margin:4px 0;}

  </style>
</head>
<body>
<div class="wrap">
  <div class="main">
    <h2 id="title">Session {{ session_id }}</h2>
    <div class="muted" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
      <span>Session ID: <code>{{ session_id }}</code></span>
      <button id="btnCopyLink" onclick="copyInviteLink()" disabled>Копировать ссылку</button>
    </div>

    <div class="log" id="log"></div>

    <div class="row">
      <input id="msg" placeholder="Действие / команда (roll, adv, dis, ooc, gm, name, pass...)"/>
      <button id="btnSend" onclick="sendMsg()">Отправить</button>
    </div>
    <div id="turnHint" class="hintline"></div>

    <div class="row">
      <button id="btnBegin" onclick="wsAction('begin')">Start</button>
      <button id="btnPause" onclick="wsAction('pause')">Pause</button>
      <button id="btnResume" onclick="wsAction('resume')">Resume</button>
      <button id="btnSkip" onclick="wsAction('skip')">Skip</button>
      <button id="btnStatus" onclick="wsAction('status')">Статус</button>
      <button id="btnReady" onclick="toggleReady()">Ready</button>
      <button id="btnLeave" onclick="leaveNow()">Выйти</button>
    </div>

    <div class="muted" style="margin-top:10px;">
      Подсказка: <code>help</code>, <code>char create Алена Rogue</code>, <code>me</code>, <code>hp -3</code>, <code>check wis dc15</code>, <code>check adv stealth dc14</code>.
    </div>
  </div>

  <div class="side">
    <h3>Игроки</h3>
    <div id="players"></div>

    <h3 style="margin-top:18px;">Мой персонаж</h3>
    <div id="myChar" class="player muted char-card" role="button" tabindex="0" title="Открыть карточку персонажа">Создай: <code>char create Имя Класс</code></div>
    <div id="charActionRow" class="row" style="margin-top:8px;">
      <button id="btnGoChar" onclick="location.href='/c/' + SESSION_ID;">Создать/изменить персонажа</button>
    </div>

    <h3 style="margin-top:18px;">Таймер</h3>
    <div id="timer" class="player">—</div>
    <div class="combat-log" id="combatLog">
      <button id="combatLogToggle" class="combat-log-toggle" type="button" aria-expanded="false" aria-controls="combatLogContent">
        <span>Боевой журнал</span>
        <span id="combatLogIndicator" class="combat-log-indicator">▸</span>
      </button>
      <div id="combatLogContent" class="combat-log-content" hidden>
        <div class="combat-log-status">Бой не начат</div>
        <div class="combat-log-placeholder">Здесь будут отображаться броски кубиков и механика боя.</div>
        <div class="combat-log-placeholder">Пример: Атака → бросок d20 → попадание/промах.</div>
      </div>
    </div>
  </div>
</div>

<div id="charModal" class="char-modal" aria-hidden="true">
  <div class="char-modal-window" role="dialog" aria-modal="true" aria-labelledby="charModalTitle">
    <div class="char-modal-head">
      <h3 id="charModalTitle" class="char-modal-title">Карточка персонажа</h3>
      <div class="char-modal-actions">
        <span id="charModalCopyToast" class="char-modal-toast" aria-live="polite">Скопировано</span>
        <button id="charModalCopy" class="char-modal-copy" type="button">Скопировать</button>
        <button id="charModalClose" class="char-modal-close" type="button" aria-label="Закрыть">×</button>
      </div>
    </div>
    <div id="charModalBody" class="char-grid"></div>
  </div>
</div>

<script>
const SESSION_ID = "{{ session_id }}";
let ws = null;
let lastLoggedReconnectDelaySec = null;
let heartbeatInt = null;
let manualLeave = false;
let charModalCopyText = "";
let charModalToastTimer = null;

let lastState = null;
let uiCtx = {
  connected: false,
  started: false,
  paused: false,
  myTurn: false,
  iAmAdmin: false,
  me: null,
};

function normText(s){ return (s||"").trim(); }
function startsWithRe(text, re){ return re.test(normText(text)); }

function isOOC(text){
  const t = normText(text);
  return /^ooc\b/i.test(t) || /^\/\//.test(t);
}
function isHelp(text){ return /^help\b/i.test(normText(text)); }
function isName(text){ return /^\/?name\b/i.test(normText(text)); }
function isGM(text){ return /^gm\b/i.test(normText(text)); }
function isKick(text){ return /^\/?kick\b/i.test(normText(text)); }
function isLeave(text){ return /^\/?(leave|quit|exit)\b/i.test(normText(text)); }
function isCharCmd(text){ return /^\/?char\b/i.test(normText(text)); }
function isMeCmd(text){ return /^\/?me\b/i.test(normText(text)); }
function isHpCmd(text){ return /^\/?hp\s+[+-]?\d+\b/i.test(normText(text)); }
function isStaCmd(text){ return /^\/?sta\s+[+-]?\d+\b/i.test(normText(text)); }
function isStatCmd(text){ return /^\/?stat\b/i.test(normText(text)); }
function isCheckCmd(text){ return /^\/?check\b/i.test(normText(text)); }
function isDice(text){ return /^(roll|adv|dis)\b/i.test(normText(text)) || /^\d+d\d+([+-]\d+)?$/i.test(normText(text)); }
function isPass(text){ return /^(pass|end)\b/i.test(normText(text)); }
function isWsOpen(){ return !!ws && ws.readyState === WebSocket.OPEN; }
function stopHeartbeat(){
  if(heartbeatInt){
    clearInterval(heartbeatInt);
    heartbeatInt = null;
  }
}
function startHeartbeat(){
  stopHeartbeat();
  heartbeatInt = setInterval(() => {
    if(isWsOpen()){
      ws.send(JSON.stringify({action:"ping"}));
    }
  }, 15000);
}

function canSendText(text){
  const t = normText(text);
  if(!t) return false;
  if(!uiCtx.connected) return false;

  // always allowed
  if(isLeave(t)) return true;
  if(uiCtx.me && uiCtx.me.is_active === false) return false;
  if(isHelp(t) || isName(t) || isOOC(t)) return true;
  if(isGM(t)) return !!uiCtx.iAmAdmin;
  if(isKick(t)) return !!uiCtx.iAmAdmin;
  if(isCharCmd(t) || isMeCmd(t) || isHpCmd(t) || isStaCmd(t) || isCheckCmd(t)) return true;
  if(isStatCmd(t)) return !!uiCtx.iAmAdmin || !uiCtx.started;

  // turn-required commands/messages
  if(!uiCtx.started) return false;
  if(uiCtx.paused) return false;
  if(!uiCtx.myTurn) return false;
  return true;
}

function updateSendAvailability(){
  const inp = document.getElementById('msg');
  const btn = document.getElementById('btnSend');
  const hint = document.getElementById('turnHint');
  if(!inp || !btn || !hint) return;

  inp.disabled = !uiCtx.connected;
  const btnStatus = document.getElementById("btnStatus");
  if(btnStatus){
    btnStatus.disabled = !uiCtx.connected;
  }
  const btnReady = document.getElementById("btnReady");
  if(btnReady){
    const noChar = !uiCtx.me || !uiCtx.me.char;
    btnReady.disabled = !uiCtx.connected || noChar || (uiCtx.me && uiCtx.me.is_active === false);
  }
  const btnLeave = document.getElementById("btnLeave");
  if(btnLeave){
    btnLeave.disabled = !uiCtx.connected;
  }
  const btnCopyLink = document.getElementById("btnCopyLink");
  if(btnCopyLink){
    btnCopyLink.disabled = !uiCtx.connected;
  }
  const kickButtons = document.querySelectorAll(".btn-kick");
  for(const el of kickButtons){
    el.disabled = !uiCtx.connected;
  }
  const adminButtons = ["btnBegin", "btnPause", "btnResume", "btnSkip"];
  for(const id of adminButtons){
    const el = document.getElementById(id);
    if(el && !uiCtx.connected){
      el.disabled = true;
    }
  }

  // input highlight
  inp.classList.remove('input-ok','input-wait','input-bad');

  const t = normText(inp.value);
  const allowed = canSendText(t);
  btn.disabled = !allowed;

  // Hint text
  if(!uiCtx.connected){
    inp.classList.add('input-bad');
    hint.className = 'hintline hint-bad';
    hint.textContent = 'Нет соединения с сервером (WebSocket).';
    return;
  }
  if(uiCtx.me && uiCtx.me.is_active === false){
    inp.classList.add('input-wait');
    hint.className = 'hintline hint-wait';
    hint.textContent = 'Ты offline в этой сессии. Доступно только: /leave.';
    return;
  }
  if(!uiCtx.started){
    // before start: utility commands are allowed
    inp.classList.add('input-wait');
    hint.className = 'hintline hint-wait';
    hint.textContent = uiCtx.iAmAdmin
      ? 'Игра не началась: нажми Start когда все готовы. Можно: help, ooc, name, gm, char/me/hp/sta/check, stat.'
      : 'Игра не началась: нажми Ready. Можно: help, ooc, name, char/me/hp/sta/check, stat (только себе).';
    return;
  }
  if(uiCtx.paused){
    inp.classList.add('input-wait');
    hint.className = 'hintline hint-wait';
    hint.textContent = uiCtx.iAmAdmin
      ? 'Пауза: Resume чтобы продолжить. Можно: help, ooc, name, gm, char/me/hp/sta/check, stat.'
      : 'Пауза: ждём. Можно: help, ooc, name, char/me/hp/sta/check.';
    return;
  }
  if(uiCtx.myTurn){
    inp.classList.add('input-ok');
    hint.className = 'hintline hint-ok';
    hint.textContent = 'Твой ход. Пиши действие или команду. (roll/adv/dis не тратят ход)';
    return;
  }
  inp.classList.add('input-wait');
  hint.className = 'hintline hint-wait';
  hint.textContent = 'Сейчас не твой ход. Можно: ooc/.., help, name, char/me/hp/sta/check' + (uiCtx.iAmAdmin ? ', gm, stat' : '') + '.';
}

let timerInt = null;
let timerRemain = null;
let timerSyncedAt = 0;

function stopLocalTimer(){
  if(timerInt){ clearInterval(timerInt); timerInt = null; }
  timerRemain = null;
  timerSyncedAt = 0;
}
function startLocalTimer(rem){
  stopLocalTimer();
  timerRemain = Number(rem);
  timerSyncedAt = Date.now();
  timerInt = setInterval(() => {
    const passed = Math.floor((Date.now() - timerSyncedAt) / 1000);
    const left = Math.max(0, timerRemain - passed);
    const t = document.getElementById("timer");
    t.textContent = "Осталось: " + left + " сек";
  }, 250);
}

function getUID(){
  let uid = localStorage.getItem("uid");
  if(!uid){
    uid = String(Math.floor(1000000000 + Math.random()*9000000000));
    localStorage.setItem("uid", uid);
  }
  return Number(uid);
}
function getClientId(){
  let cid = localStorage.getItem("client_id");
  if(!cid){
    if(window.crypto && crypto.randomUUID){
      cid = crypto.randomUUID();
    }else{
      cid = (Date.now().toString(16) + Math.random().toString(16).slice(2));
    }
    localStorage.setItem("client_id", cid);
  }
  return cid;
}
function getName(){
  let name = localStorage.getItem("name");
  if(!name){
    name = prompt("Имя игрока (как тебя показывать):", "Игрок");
    if(!name) name = "Игрок";
    localStorage.setItem("name", name);
  }
  return name;
}
function setNameLocal(newName){
  if(!newName) return;
  localStorage.setItem("name", newName);
}

function escapeHtml(s){
  return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}
function prettyStatValue(ch, keys){
  const stats = (ch && typeof ch.stats === "object" && ch.stats) ? ch.stats : {};
  for(const key of keys){
    const v = stats[key];
    if(v !== null && v !== undefined && v !== ""){
      return v;
    }
  }
  return "—";
}
function renderInventoryHtml(inv){
  if(!Array.isArray(inv) || inv.length === 0){
    return "<div class='char-line'><strong>Инвентарь:</strong> пусто</div>";
  }
  const rows = [];
  for(const raw of inv){
    if(!raw || typeof raw !== "object") continue;
    const name = String(raw.name || "").trim();
    if(!name) continue;
    const qtyRaw = Number(raw.qty);
    const qty = Number.isFinite(qtyRaw) ? Math.max(1, Math.floor(qtyRaw)) : 1;
    rows.push(`<li>${escapeHtml(name)} x${qty}</li>`);
  }
  if(rows.length === 0){
    return "<div class='char-line'><strong>Инвентарь:</strong> пусто</div>";
  }
  return `<div class='char-line'><strong>Инвентарь:</strong><ul class='char-list'>${rows.join("")}</ul></div>`;
}
function getInventoryText(inv){
  if(!Array.isArray(inv) || inv.length === 0) return "пусто";
  const rows = [];
  for(const raw of inv){
    if(!raw || typeof raw !== "object") continue;
    const name = String(raw.name || "").trim();
    if(!name) continue;
    const qtyRaw = Number(raw.qty);
    const qty = Number.isFinite(qtyRaw) ? Math.max(1, Math.floor(qtyRaw)) : 1;
    rows.push(`${name} x${qty}`);
  }
  return rows.length ? rows.join(", ") : "пусто";
}
function firstFilled(){
  for(const val of arguments){
    if(val === null || val === undefined) continue;
    const txt = String(val).trim();
    if(txt) return txt;
  }
  return "";
}
function readZoneFromPositionEntry(entry){
  if(!entry || typeof entry !== "object") return "";
  return firstFilled(entry.zone, entry.location, entry.area, entry.position_zone);
}
function resolveCharacterZone(st, me, ch){
  if(!st) return "неизвестно";

  const myUid = String((me && me.uid !== undefined && me.uid !== null) ? me.uid : getUID());
  const charName = String((ch && ch.name) || "").trim().toLowerCase();

  const meZone = firstFilled(me && me.zone);
  if(meZone) return meZone;

  const pcPositions = st.game && st.game.pc_positions;
  if(pcPositions && typeof pcPositions === "object"){
    const pcEntry = pcPositions[myUid];
    const pcZone = (pcEntry && typeof pcEntry === "object")
      ? readZoneFromPositionEntry(pcEntry)
      : firstFilled(pcEntry);
    if(pcZone) return pcZone;
  }

  if(!me && Array.isArray(st.players)){
    const player = st.players.find((p) => p && String(p.uid) === myUid);
    const playerZone = firstFilled(player && player.zone);
    if(playerZone) return playerZone;
  }

  const direct = firstFilled(st.zone, st.my_character_zone, ch && ch.zone);
  if(direct) return direct;

  const positions = st.positions_block;
  if(!positions) return "неизвестно";

  if(typeof positions === "string"){
    const text = positions.trim();
    return text || "неизвестно";
  }
  if(Array.isArray(positions)){
    for(const item of positions){
      if(!item || typeof item !== "object") continue;
      const uid = firstFilled(item.uid, item.player_uid, item.playerId, item.player_id);
      const name = firstFilled(item.character_name, item.char_name, item.name).toLowerCase();
      if((uid && uid === myUid) || (charName && name === charName)){
        const zone = readZoneFromPositionEntry(item);
        if(zone) return zone;
      }
    }
    return "неизвестно";
  }
  if(typeof positions === "object"){
    const byUid = positions.by_uid;
    if(byUid && typeof byUid === "object" && byUid[myUid]){
      const zone = readZoneFromPositionEntry(byUid[myUid]);
      if(zone) return zone;
    }
    if(positions[myUid]){
      const zone = readZoneFromPositionEntry(positions[myUid]);
      if(zone) return zone;
    }
    if(charName && positions.by_character && typeof positions.by_character === "object"){
      const byChar = positions.by_character[charName];
      const zone = readZoneFromPositionEntry(byChar);
      if(zone) return zone;
    }
    const fallback = readZoneFromPositionEntry(positions);
    if(fallback) return fallback;
  }
  return "неизвестно";
}
function showCharacterCopyToast(){
  const toast = document.getElementById("charModalCopyToast");
  if(!toast) return;
  toast.classList.add("show");
  if(charModalToastTimer){
    clearTimeout(charModalToastTimer);
  }
  charModalToastTimer = setTimeout(() => {
    toast.classList.remove("show");
    charModalToastTimer = null;
  }, 1500);
}
async function copyCharacterCard(){
  if(!charModalCopyText) return;
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(charModalCopyText);
      showCharacterCopyToast();
      return;
    }
  }catch(_e){}
  prompt("Скопируйте карточку персонажа:", charModalCopyText);
  showCharacterCopyToast();
}
function getCharacterFromState(){
  if(!lastState || !Array.isArray(lastState.players)) return null;
  const myUid = getUID();
  const me = lastState.players.find(p => p.uid === myUid) || null;
  return me && me.char ? me.char : null;
}
function showCreateCharacterHint(){
  logLine("[hint] Сначала создайте персонажа");
}
function openCharacterModal(){
  const me = lastState && Array.isArray(lastState.players)
    ? (lastState.players.find(p => p.uid === getUID()) || null)
    : null;
  const ch = me && me.char ? me.char : null;
  if(!ch){
    showCreateCharacterHint();
    return;
  }
  const klass = ch.class_skin || ch.class_kit || "Adventurer";
  const zone = resolveCharacterZone(lastState, me, ch);
  const statsText = [
    `Сила: ${prettyStatValue(ch, ["str"])}`,
    `Ловкость: ${prettyStatValue(ch, ["dex"])}`,
    `Выносливость: ${prettyStatValue(ch, ["con"])}`,
    `Интеллект: ${prettyStatValue(ch, ["int"])}`,
    `Воля: ${prettyStatValue(ch, ["wil", "wis"])}`,
    `Харизма: ${prettyStatValue(ch, ["cha"])}`
  ];
  const skillsText = "— (в разработке)";
  const details = [];
  details.push(`<div class="char-line"><strong>Имя:</strong> ${escapeHtml(ch.name || "—")}</div>`);
  details.push(`<div class="char-line"><strong>Класс:</strong> ${escapeHtml(klass)}</div>`);
  details.push(`<div class="char-line"><strong>Уровень:</strong> ${escapeHtml(String(ch.level ?? "—"))}</div>`);
  if(String(ch.gender || "").trim()){
    details.push(`<div class="char-line"><strong>Пол:</strong> ${escapeHtml(ch.gender)}</div>`);
  }
  if(String(ch.race || "").trim()){
    details.push(`<div class="char-line"><strong>Раса:</strong> ${escapeHtml(ch.race)}</div>`);
  }
  details.push(`<div class="char-line"><strong>Зона:</strong> ${escapeHtml(zone)}</div>`);
  if(String(ch.description || "").trim()){
    details.push(`<div class="char-line"><strong>Описание:</strong> ${escapeHtml(ch.description)}</div>`);
  }
  details.push(`<div class="char-line"><strong>HP / STA:</strong> ${escapeHtml(String(ch.hp ?? "—"))}/${escapeHtml(String(ch.hp_max ?? "—"))} | ${escapeHtml(String(ch.sta ?? "—"))}/${escapeHtml(String(ch.sta_max ?? "—"))}</div>`);
  details.push(renderInventoryHtml(ch.inventory));
  details.push(
    "<div class='char-line'><strong>Атрибуты:</strong><ul class='char-list'>" +
    `<li>Сила: ${escapeHtml(String(prettyStatValue(ch, ["str"])))}</li>` +
    `<li>Ловкость: ${escapeHtml(String(prettyStatValue(ch, ["dex"])))}</li>` +
    `<li>Выносливость: ${escapeHtml(String(prettyStatValue(ch, ["con"])))}</li>` +
    `<li>Интеллект: ${escapeHtml(String(prettyStatValue(ch, ["int"])))}</li>` +
    `<li>Воля: ${escapeHtml(String(prettyStatValue(ch, ["wil", "wis"])))}</li>` +
    `<li>Харизма: ${escapeHtml(String(prettyStatValue(ch, ["cha"])))}</li>` +
    "</ul></div>"
  );
  details.push(`<div class='char-line'><strong>Навыки:</strong> ${escapeHtml(skillsText)}</div>`);

  const copyLines = [
    `Имя: ${String(ch.name || "—")}`,
    `Класс: ${String(klass)}`,
    `Уровень: ${String(ch.level ?? "—")}`
  ];
  const gender = String(ch.gender || "").trim();
  const race = String(ch.race || "").trim();
  if(gender || race){
    copyLines.push(`Пол/Раса: ${gender || "—"} / ${race || "—"}`);
  }
  copyLines.push(`Зона: ${zone}`);
  copyLines.push(`HP/STA: ${String(ch.hp ?? "—")}/${String(ch.hp_max ?? "—")} | ${String(ch.sta ?? "—")}/${String(ch.sta_max ?? "—")}`);
  copyLines.push(`Инвентарь: ${getInventoryText(ch.inventory)}`);
  copyLines.push(`Атрибуты: ${statsText.join(", ")}`);
  copyLines.push(`Навыки: ${skillsText}`);
  charModalCopyText = copyLines.join("\n");

  const body = document.getElementById("charModalBody");
  const modal = document.getElementById("charModal");
  const copyBtn = document.getElementById("charModalCopy");
  if(!body || !modal) return;
  body.innerHTML = details.join("");
  if(copyBtn){
    copyBtn.disabled = !charModalCopyText;
  }
  modal.classList.add("open");
  modal.setAttribute("aria-hidden", "false");
}
function closeCharacterModal(){
  const modal = document.getElementById("charModal");
  if(!modal) return;
  if(charModalToastTimer){
    clearTimeout(charModalToastTimer);
    charModalToastTimer = null;
  }
  const toast = document.getElementById("charModalCopyToast");
  if(toast){
    toast.classList.remove("show");
  }
  modal.classList.remove("open");
  modal.setAttribute("aria-hidden", "true");
}
function logLine(text){
  const el = document.getElementById("log");
  el.innerHTML += "<div style='margin-bottom:6px; white-space:pre-wrap;'>" + escapeHtml(text) + "</div>";
  el.scrollTop = el.scrollHeight;
}

function getRequestIdFromResponse(response){
  if(!response || !response.headers) return null;
  return response.headers.get("X-Request-ID") || response.headers.get("x-request-id");
}

function prepareKick(order, name){
  const inp = document.getElementById("msg");
  if(!inp) return;
  inp.value = `/kick ${order}`;
  inp.focus();
  updateSendAvailability();
  logLine(`[client] prepared /kick ${order} for ${name}`);
}

async function copyInviteLink(){
  try{
    await navigator.clipboard.writeText(location.href);
    logLine("[client] link copied");
  }catch(_e){
    logLine("[client] can't copy link");
  }
}

async function joinIfNeeded(){
  const uid = getUID();
  const name = getName();
  const cid = getClientId();

  const r = await fetch("/api/join", {
    method:"POST",
    headers:{"Content-Type":"application/json", "X-Client-ID": cid},
    body: JSON.stringify({session_id: SESSION_ID, uid, name})
  });
  const data = await r.json();
  if(!r.ok){
    const msg = data.detail || "Ошибка join";
    const rid = getRequestIdFromResponse(r);
    logLine("[error] join: " + msg + (rid ? ` (rid=${rid})` : ""));
    // не блокируем websocket — просто покажем ошибку
    return false;
  }
  return true;
}

let reconnectDelay = 1000; // старт 1с, дальше увеличиваем до лимита

async function start(){
  // гарантируем, что uid/name уже сохранены
  getUID();
  getClientId();
  getName();
  connectWS();
}

function connectWS(){
  // защита от параллельных подключений
  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
    return;
  }

  const uid = getUID();
  const cid = encodeURIComponent(getClientId());
  const proto = (location.protocol === "https:") ? "wss" : "ws";
  ws = new WebSocket(`${proto}://${location.host}/ws/${SESSION_ID}?uid=${uid}&cid=${cid}`);

  ws.onopen = async () => {
    uiCtx.connected = true;
    manualLeave = false;
    reconnectDelay = 1000; // сбрасываем паузу при успешном коннекте
    lastLoggedReconnectDelaySec = null; // заново логируем ступени при следующем оффлайне
    startHeartbeat();
    logLine("[client] connected");
    updateSendAvailability();

    // ВАЖНО: join делаем только когда сервер доступен (WS открылся)
    try { await joinIfNeeded(); } catch(e) {}
  };

  ws.onmessage = (ev) => {
    const data = JSON.parse(ev.data);
    if(data.type === "state"){
      renderState(data);
    } else if(data.type === "error"){
      logLine("[error] " + data.message + (data.request_id ? ` (rid=${data.request_id})` : ""));
      if(data.fatal){ alert(data.message); }
    }
  };

  ws.onclose = () => {
    stopHeartbeat();
    uiCtx.connected = false;
    updateSendAvailability();
    if(manualLeave){
      logLine("[client] disconnected (leave)");
      return;
    }
    const retrySec = Math.round(reconnectDelay / 1000);
    if(lastLoggedReconnectDelaySec !== retrySec){
      logLine(`[client] disconnected, retry in ${retrySec}s`);
      lastLoggedReconnectDelaySec = retrySec;
    }
    const delay = reconnectDelay;
    reconnectDelay = Math.min(10000, reconnectDelay * 2); // максимум 10с
    setTimeout(connectWS, delay);
  };
}



function renderState(st){
  lastState = st;
  let title = st.session.title + " (turn " + (st.session.turn_index || 0);
  if(st.session.initiative_fixed && st.session.round){
    title += ", round " + st.session.round;
  }
  title += ")";
  document.getElementById("title").textContent = title;

  const myUid = getUID();
  const me = (st.players || []).find(p => p.uid === myUid) || null;
  const iAmAdmin = !!(me && me.is_admin);
  uiCtx.me = me;
  uiCtx.iAmAdmin = iAmAdmin;
  uiCtx.started = !!st.session.is_active;
  uiCtx.paused = !!st.session.is_paused;
  uiCtx.myTurn = !!(me && me.is_current && me.is_active) && !uiCtx.paused;


  // buttons
  document.getElementById("btnBegin").disabled = !iAmAdmin || !st.session.can_begin;
  document.getElementById("btnPause").disabled = !iAmAdmin || !st.session.is_active || st.session.is_paused;
  document.getElementById("btnResume").disabled = !iAmAdmin || !st.session.is_active || !st.session.is_paused;
  document.getElementById("btnSkip").disabled = !iAmAdmin || !st.session.is_active || st.session.is_paused;

  const btnReady = document.getElementById("btnReady");
  if(me){
    btnReady.textContent = me.is_ready ? "Unready" : "Ready";
  }else{
    btnReady.textContent = "Ready";
  }

  // players list
  const p = document.getElementById("players");
  p.innerHTML = "";
  for(const pl of st.players){
    const div = document.createElement("div");
    div.className = "player" + (pl.is_current ? " cur" : "") + (pl.uid === myUid ? " me" : "") + (!pl.is_active ? " inactive" : "");

    const readyMark = pl.is_active ? (pl.is_ready ? "✅" : "⏳") : "⚪";
    const adminMark = pl.is_admin ? " [admin]" : "";
    const offlineMark = pl.is_active ? "" : " [offline]";
    const initMark = (pl.initiative !== null && pl.initiative !== undefined) ? (" | init: " + pl.initiative) : "";
    const line = document.createElement("div");
    line.style.display = "flex";
    line.style.alignItems = "center";
    line.style.justifyContent = "space-between";
    line.style.gap = "8px";

    const info = document.createElement("span");
    info.textContent = `#${pl.order} ${readyMark} ${pl.name}${adminMark}${offlineMark}${initMark}`;
    line.appendChild(info);

    if(iAmAdmin && String(pl.uid) !== String(myUid)){
      const kickBtn = document.createElement("button");
      kickBtn.className = "btn-kick";
      kickBtn.textContent = "Кик";
      kickBtn.disabled = !uiCtx.connected;
      kickBtn.onclick = () => prepareKick(pl.order, pl.name);
      line.appendChild(kickBtn);
    }
    div.appendChild(line);
    p.appendChild(div);
  }

  const myChar = document.getElementById("myChar");
  const btnGoChar = document.getElementById("btnGoChar");
  const charActionRow = document.getElementById("charActionRow");
  if(myChar){
    const ch = me ? me.char : null;
    if(ch){
      const klass = ch.class_skin || ch.class_kit || "Adventurer";
      myChar.textContent = `Персонаж: ${ch.name} (${klass}) | HP ${ch.hp}/${ch.hp_max} | STA ${ch.sta}/${ch.sta_max} | lvl ${ch.level}`;
      myChar.classList.remove("muted");
      if(btnGoChar) btnGoChar.style.display = "none";
      if(charActionRow) charActionRow.style.display = "none";
    } else {
      myChar.textContent = "Create character first. Открой страницу персонажа: /c/<session_id>";
      myChar.classList.add("muted");
      if(btnGoChar) btnGoChar.style.display = "";
      if(charActionRow) charActionRow.style.display = "";
    }
  }

  // log
  const el = document.getElementById("log");
  el.innerHTML = "";
  for(const e of st.events){
    logLine(`[${e.turn}] ${e.text}`);
  }

  // timer
  const t = document.getElementById("timer");
  if(st.session.is_paused){
    stopLocalTimer();
    t.textContent = "PAUSED";
  } else if(st.session.remaining_seconds === null || st.session.remaining_seconds === undefined){
    stopLocalTimer();
    t.textContent = "—";
  } else {
    startLocalTimer(st.session.remaining_seconds);
  }

  updateSendAvailability();
}

function sendMsg(){
  const inp = document.getElementById("msg");
  const text = (inp.value || "").trim();
  if(!text) return;
  if(isLeave(text)){
    inp.value = "";
    leaveNow();
    return;
  }
  if(!isWsOpen()){
    logLine("[client] offline: can't send message");
    updateSendAvailability();
    return;
  }
  if(!canSendText(text)){
    // don't send forbidden messages; UI should already block the button
    updateSendAvailability();
    return;
  }
  inp.value = "";

  // client-side name sync (so refresh won't revert)
  const m = text.match(/^\/?name\s+(.+)$/i);
  if(m && m[1]){
    setNameLocal(m[1].trim());
  }

  ws.send(JSON.stringify({action:"say", text}));
}

function leaveNow(){
  manualLeave = true;
  if(!isWsOpen()){
    logLine("[client] offline: can't leave");
    return;
  }
  try { ws.send(JSON.stringify({action:"leave"})); } catch(_e){}
  stopHeartbeat();
  try { ws.close(1000, "leave"); } catch(_e){}
}

function wsAction(action){
  if(!isWsOpen()){
    logLine("[client] offline: can't send action: " + action);
    return;
  }
  ws.send(JSON.stringify({action}));
}

function toggleReady(){
  if(!ws || ws.readyState !== 1){
    logLine("[error] websocket not connected");
    return;
  }
  const myUid = getUID();
  const me = lastState ? (lastState.players || []).find(p => p.uid === myUid) : null;
  const action = (me && me.is_ready) ? "unready" : "ready";
  ws.send(JSON.stringify({action}));
}


// realtime enable/disable while typing + Enter to send
(function attachInputHandlers(){
  const inp = document.getElementById('msg');
  if(!inp) return;
  inp.addEventListener('input', () => updateSendAvailability());
  inp.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' && !e.shiftKey){
      e.preventDefault();
      sendMsg();
    }
  });
})();

(function attachCharacterCardHandlers(){
  const card = document.getElementById("myChar");
  const modal = document.getElementById("charModal");
  const closeBtn = document.getElementById("charModalClose");
  const copyBtn = document.getElementById("charModalCopy");
  if(card){
    card.addEventListener("click", openCharacterModal);
    card.addEventListener("keydown", (e) => {
      if(e.key === "Enter" || e.key === " "){
        e.preventDefault();
        openCharacterModal();
      }
    });
  }
  if(closeBtn){
    closeBtn.addEventListener("click", closeCharacterModal);
  }
  if(copyBtn){
    copyBtn.addEventListener("click", copyCharacterCard);
  }
  if(modal){
    modal.addEventListener("click", (e) => {
      if(e.target === modal){
        closeCharacterModal();
      }
    });
  }
  document.addEventListener("keydown", (e) => {
    if(e.key === "Escape"){
      closeCharacterModal();
    }
  });
})();

(function attachCombatLogToggle(){
  const toggle = document.getElementById("combatLogToggle");
  const content = document.getElementById("combatLogContent");
  const indicator = document.getElementById("combatLogIndicator");
  if(!toggle || !content || !indicator) return;
  toggle.addEventListener("click", () => {
    const expanded = toggle.getAttribute("aria-expanded") === "true";
    const next = !expanded;
    toggle.setAttribute("aria-expanded", next ? "true" : "false");
    content.hidden = !next;
    indicator.textContent = next ? "▾" : "▸";
  });
})();

// стартуем: join не должен блокировать ws
start();
</script>
</body>
</html>
